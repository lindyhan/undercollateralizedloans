{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (token/ERC20/extensions/IERC20Permit.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC-20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[ERC-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC-20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n *\n * ==== Security Considerations\n *\n * There are two important considerations concerning the use of `permit`. The first is that a valid permit signature\n * expresses an allowance, and it should not be assumed to convey additional meaning. In particular, it should not be\n * considered as an intention to spend the allowance in any specific way. The second is that because permits have\n * built-in replay protection and can be submitted by anyone, they can be frontrun. A protocol that uses permits should\n * take this into consideration and allow a `permit` call to fail. Combining these two aspects, a pattern that may be\n * generally recommended is:\n *\n * ```solidity\n * function doThingWithPermit(..., uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) public {\n *     try token.permit(msg.sender, address(this), value, deadline, v, r, s) {} catch {}\n *     doThing(..., value);\n * }\n *\n * function doThing(..., uint256 value) public {\n *     token.safeTransferFrom(msg.sender, address(this), value);\n *     ...\n * }\n * ```\n *\n * Observe that: 1) `msg.sender` is used as the owner, leaving no ambiguity as to the signer intent, and 2) the use of\n * `try/catch` allows the permit to fail and makes the code tolerant to frontrunning. (See also\n * {SafeERC20-safeTransferFrom}).\n *\n * Additionally, note that smart contract wallets (such as Argent or Safe) are not able to produce permit signatures, so\n * contracts should have entry points that don't rely on permit.\n */\ninterface IERC20Permit {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     *\n     * CAUTION: See Security Considerations above.\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC-20 standard as defined in the ERC.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the value of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the value of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\n     * allowance mechanism. `value` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n}\n"
    },
    "contracts/Loan_.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0 <0.9.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Permit.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ninterface IEthenaStaking {\n    function stake(address user, uint256 amount) external returns (uint256 sUSDeAmount);\n}\n\ncontract Loan {\n    IERC20Permit public usdcTokenPermit;  // For permit functionality\n    IERC20 public usdcToken;  // For balanceOf function\n    IERC20 public usdEToken;\n    address public aavePool;  // Just the address, no need for IPool interface\n    IEthenaStaking public ethenaStaking;\n\n    address public deployer;\n\n    struct UserDeposit {\n        uint256 usdEAmount;\n        uint256 sUsdEAmount;\n        uint256 usdcAmount;\n        uint256 aEthUsdcAmount;\n    }\n\n    mapping(address => UserDeposit) public userDeposits;\n\n    constructor(address _usdEToken, address _usdcToken, address _aavePool, address _ethenaStaking, address _deployer) {\n        usdEToken = IERC20(_usdEToken);\n        usdcTokenPermit = IERC20Permit(_usdcToken);  // IERC20Permit for permit functionality\n        usdcToken = IERC20(_usdcToken);  // IERC20 for balanceOf functionality\n        aavePool = _aavePool;  // Just store the address\n        ethenaStaking = IEthenaStaking(_ethenaStaking);\n        deployer = _deployer;\n    }\n\n    function approve(uint256 _amount) external {\n        // Approve the Ethena staking contract to spend the specified amount of USDe on behalf of the client\n        usdEToken.transferFrom(msg.sender, address(ethenaStaking), _amount);\n    }\n\n    function stake(uint256 _usdEAmount) external {\n        // Ensure that the sender has approved the USDe tokens\n        require(usdEToken.allowance(msg.sender, address(ethenaStaking)) >= _usdEAmount, \"Approval not sufficient\");\n\n        // Send USDe to Ethena staking contract\n        usdEToken.transferFrom(msg.sender, address(ethenaStaking), _usdEAmount);\n\n        // Stake the USDe and receive sUSDe\n        uint256 sUsdEAmount = ethenaStaking.stake(address(this), _usdEAmount);\n\n        // Map the transaction values to the user's wallet\n        userDeposits[msg.sender].usdEAmount = _usdEAmount;\n        userDeposits[msg.sender].sUsdEAmount = sUsdEAmount;\n    }\n\n    function depositToAave(uint256 _usdEAmount, uint256 _leverage, uint256 _deadline, uint8 _permitV, bytes32 _permitR, bytes32 _permitS) external {\n        // Ensure that only the deployer wallet can call this function\n        require(msg.sender == deployer, \"Only deployer can call this function\");\n\n        // Calculate the USDC amount (USD * leverage)\n        uint256 usdcAmount = _usdEAmount * _leverage;\n\n        // Approve Aave pool to spend USDC from the deployer using the permit function\n        usdcTokenPermit.permit(address(this), aavePool, usdcAmount, _deadline, _permitV, _permitR, _permitS);\n\n        // Deposit USDC into Aave pool (Aave will return aEthUSDC)\n        (bool success, ) = aavePool.call{value: usdcAmount}(abi.encodeWithSignature(\"supply(address,uint256,address,uint16)\", usdcToken, usdcAmount, address(this), 0));\n\n        require(success, \"Aave supply failed\");\n\n        // Receive the corresponding aEthUSDC tokens\n        uint256 aEthUsdcAmount = usdcToken.balanceOf(address(this));  // Correctly use IERC20 for balanceOf\n\n        // Store the deposit data (aEthUSDC amount) in the contract\n        userDeposits[msg.sender].usdcAmount = usdcAmount;\n        userDeposits[msg.sender].aEthUsdcAmount = aEthUsdcAmount;\n    }\n\n    function closeLoan() external {\n        UserDeposit storage userDeposit = userDeposits[msg.sender];\n\n        // 1. Unstake sUSDe and get back USDe\n        ethenaStaking.stake(msg.sender, userDeposit.sUsdEAmount);\n\n        // 2. Withdraw aEthUSDC from Aave\n        (bool success, ) = aavePool.call{value: userDeposit.aEthUsdcAmount}(abi.encodeWithSignature(\"withdraw(address,uint256,address)\", usdcToken, userDeposit.aEthUsdcAmount, address(this)));\n\n        require(success, \"Aave withdraw failed\");\n\n        // 3. Calculate the excess USDC (after interest)\n        uint256 withdrawnUSDC = usdcToken.balanceOf(address(this));\n        uint256 excessUSDC = withdrawnUSDC - userDeposit.usdcAmount;\n\n        // 4. Send excess USDC back to the user\n        usdcToken.transfer(msg.sender, excessUSDC);\n\n        // Remove user deposit record\n        delete userDeposits[msg.sender];\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}